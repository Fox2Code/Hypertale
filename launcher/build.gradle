import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Opcodes
import org.objectweb.asm.commons.ClassRemapper
import org.objectweb.asm.commons.SimpleRemapper
import org.objectweb.asm.tree.ClassNode

import java.util.jar.JarFile

buildscript {
    dependencies {
        classpath "org.ow2.asm:asm-commons:${project['asm.version']}"
    }
}

plugins {
    id 'maven-publish'
    id 'net.ltgt.errorprone'
}

final File hypertaleGradleDirectory = new File(project.gradle.gradleUserHomeDir, "hypertale")
final File workInProgress = new File(hypertaleGradleDirectory, "HytaleServerWIP.jar")
final File hypertaleInitJar = project(":init").layout.buildDirectory
        .file("libs/init-${project['hypertale.version']}.jar").get().asFile
// Improve compatibility with IntellijIDEA
if (!hypertaleInitJar.getParentFile().isDirectory() &&
        !hypertaleInitJar.getParentFile().mkdirs()) {
    throw new RuntimeException("Failed to create init \"build/libs\" folder!")
}
// Hypertale JavaPlugin support
final File classesFolder = new File(layout.buildDirectory.asFile.get(),
        "classes" + File.separator + "java" + File.separator + "main").getAbsoluteFile()
final File hypertaleJavaPlugin = new File(classesFolder, "com" + File.separator + "fox2code" +
        File.separator + "hypertale" + File.separator + "utils" + File.separator + "HypertaleBundled.class")
final File metaInfHypertaleJavaPlugin = new File(classesFolder,
        "META-INF" + File.separator + "bundled" + File.separator + "#HypertaleBundled.class")
// Hypertale: Libraries
final File hypertaleLibraries = new File(layout.buildDirectory.asFile.get(), "libs" +
        File.separator + "HypertaleLibraries-" + project['hypertale.library.version'] + ".jar")

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(25))
    }
    withSourcesJar()
    withJavadocJar()
}

configurations {
    javaAgent {
        transitive = false
        canBeConsumed = false
    }
}

dependencies {
    implementation(files(workInProgress))
    final String ASM_VERSION = project['asm.version']
    api "org.ow2.asm:asm-util:${ASM_VERSION}"
    api "org.ow2.asm:asm-commons:${ASM_VERSION}"
    api "it.unimi.dsi:fastutil:${project['fastutil.version']}"
    api "com.google.code.gson:gson:${project['gson.version']}"
    api "com.google.guava:guava:${project['guava.version']}"
    api "com.google.guava:failureaccess:${project['guava-failureaccess.version']}"
    api "net.fabricmc:sponge-mixin:${project['fabric-mixin.version']}"
    api "io.github.llamalad7:mixinextras-common:${project['mixin-extras.version']}"
    errorprone "com.google.errorprone:error_prone_core:${project['errorprone.version']}"
    include(project(":patcher"))
    // We may not have init at runtime!
    compileOnly(project(":init"))

    javaAgent("net.bytebuddy:byte-buddy-agent:${project['bytebuddy.version']}")
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testRuntimeOnly(project(":patcher")) { transitive = false }
}

// Using filesMatching in processResources during import confuse IntellijIDEA
if (!Boolean.getBoolean("idea.sync.active")) {
    processResources {
        filesMatching("manifest.json") {
            String serverVersion = null
            if (workInProgress.isFile()) {
                try (JarFile wipJarFile = new JarFile(workInProgress)) {
                    serverVersion = wipJarFile.getManifest().getMainAttributes()
                            .getValue("Implementation-Version")
                }
            }
            if (serverVersion != null) {
                expand(version: project['hypertale.version'], serverVersion: serverVersion)
            } else {
                expand(version: project['hypertale.version'], serverVersion: "Unknown")
            }
        }
    }
}

jar {
    archiveBaseName = "Hypertale"
    manifest {
        attributes 'Hypertale-Version': project['hypertale.version']
        attributes 'Hypertale-Init': project['hypertale.init']
        attributes 'Main-Class': 'com.fox2code.hypertale.launcher.Main'
        attributes 'Launcher-Agent-Class': 'com.fox2code.hypertale.launcher.HypertaleAgent'
        attributes 'Premain-Class': 'com.fox2code.hypertale.launcher.HypertaleAgent'
        attributes 'Can-Set-Native-Method-Prefix': 'true'
        attributes 'Can-Retransform-Classes': 'true'
        attributes 'Can-Redefine-Classes': 'true'
        attributes 'Sealed': 'true'
    }
    from(hypertaleInitJar)
}

tasks.register("runServer", JavaExec) {
    classpath = sourceSets.main.runtimeClasspath + project(":patcher").sourceSets.main.output
    workingDir(new File(rootProject.rootDir, "run"))
    jvmArgs(configurations.javaAgent.collect { "-javaagent:" + it.path })
    mainClass = "com.fox2code.hypertale.launcher.Main"
    standardInput = System.in
    args("--launch-dev")
}

tasks.register("makeLibraries", JavaExec) {
    classpath = sourceSets.main.runtimeClasspath + sourceSets.main.output +
            project(":patcher").sourceSets.main.output
    jvmArgs(configurations.javaAgent.collect { "-javaagent:" + it.path })
    mainClass = "com.fox2code.hypertale.launcher.Main"
    args("--make-hypertale-offline-libraries", hypertaleLibraries.getAbsolutePath())
}

compileJava {
    dependsOn(":init:jar")
    dependsOn(":patcher:jar")
    dependsOn(":patcher:checkPatchHytale")
    mustRunAfter(":patcher:patchHytale")
    doLast {
        if (!hypertaleJavaPlugin.exists()) {
            throw new RuntimeException("Compilation failed! -> " + hypertaleJavaPlugin.getPath())
        }
        File bundled = metaInfHypertaleJavaPlugin.getParentFile()
        if (!bundled.isDirectory() && !bundled.mkdirs()) {
            throw new RuntimeException("Failed to create inline destination directory!")
        }
        ClassNode classNode = new ClassNode()
        ClassReader classReader = new ClassReader(hypertaleJavaPlugin.bytes)
        classReader.accept(classNode, 0)
        if (classNode.permittedSubclasses != null) {
            classNode.permittedSubclasses.clear()
        }
        classNode.visitPermittedSubclass("com/hypixel/hytale/server/core/plugin/JavaPlugin")
        classNode.visitPermittedSubclass("com/hypixel/hytale/plugin/early/ClassTransformer")
        ClassWriter classWriter = new ClassWriter(0)
        classNode.accept(classWriter)
        hypertaleJavaPlugin.bytes = classWriter.toByteArray()
        classNode.permittedSubclasses.clear()
        classNode.access |= Opcodes.ACC_SYNTHETIC // Set synthetic to exclude it from IDE results
        classNode.fields.forEach { it.access |= Opcodes.ACC_SYNTHETIC }
        classNode.methods.forEach { it.access |= Opcodes.ACC_SYNTHETIC }
        ClassWriter classWriterMetaInf = new ClassWriter(0)
        classNode.accept(new ClassRemapper(classWriterMetaInf,
                new SimpleRemapper(Opcodes.ASM9,
                        "com/fox2code/hypertale/utils/HypertaleBundled",
                        "META-INF/bundled/#HypertaleBundled")))
        metaInfHypertaleJavaPlugin.bytes = classWriterMetaInf.toByteArray()
    }
}

afterEvaluate {
    tasks.sourcesJar {
        from(project(":patcher").tasks.sourcesJar.inputs.files) {}
    }
}

test {
    useJUnitPlatform()
}